####Set up the data for the Stan model####
#Stan requires the data set up as a list object
#Multisite Analysis
multisite_mixmod_standata <- list(
#Sample sizes
N_Sites = multisite_mixmod_data[, .N, Site_No][, .N],
N_Specimens = multisite_mixmod_data[, .N, Specimen_No][, .N],
N_Measurements = multisite_mixmod_data[, .N],
N_Element_Portions = multisite_mixmod_data[, .N, Element_Portion][, .N],
N_Measurement_Sets = multisite_mixmod_data[, .N, Measurement_Set][, .N],
#Specimen observations
Site = multisite_mixmod_data[, .N, .(Specimen_No, Element_Portion, Site_No, Immature)][order(Specimen_No), Site_No],
Element_Portion = multisite_mixmod_data[, .N, .(Specimen_No, Element_Portion, Site_No, Immature)][order(Specimen_No), Element_Portion],
Immature = multisite_mixmod_data[, .N, .(Specimen_No, Element_Portion, Site_No, Immature)][order(Specimen_No), Immature],
Immature_Proportion = as.matrix(dcast(multisite_mixmod_data[, .(Immature_Proportion = mean(Immature)), .(Site_No, Element_Portion)], Site_No ~ Element_Portion, value.var = "Immature_Proportion", fill = 0))[, 2:(multisite_mixmod_data[, .N, Element_Portion][, .N] + 1)],
#Measurement observations
Measurement_obs = multisite_mixmod_data[, Measurement_value],
Measurement_sd = multisite_mixmod_data[, Measurement_value * 0.01], #Calculate measurement error for observed measurements and reference data (1% based on data from Breslawksi and Byers 2015)
Reference_obs = multisite_mixmod_data[, .N, .(Measurement_Set, Reference_value)][order(Measurement_Set), Reference_value],
Reference_sd = multisite_mixmod_data[, .N, .(Measurement_Set, Reference_value)][order(Measurement_Set), Reference_value * 0.01],
Measurement_Set = multisite_mixmod_data[, Measurement_Set],
Specimen = multisite_mixmod_data[, Specimen_No],
#Demographic observations
N_Immature_obs = multisite_demographic_observations[, .N],
Immature_obs_site = multisite_demographic_observations[, Site_No],
Immature_obs = multisite_demographic_observations[, N_Unfused],
Immature_obs_n = multisite_demographic_observations[, N_Ageable],
N_Female_obs = multisite_demographic_observations[, .N],
Female_obs_site = multisite_demographic_observations[, Site_No],
Female_obs = multisite_demographic_observations[, N_Female],
Female_obs_n = multisite_demographic_observations[, N_Sexable],
#Prior distributions for hyper-parameters
prior_theta_raw_1 = c(-0.5, 1.5),
prior_theta_raw_2 = c(0, 1.5),
prior_mu_female = c(0, 0.2),
prior_logdelta_immature = c(-3.5, 0.5),
prior_logdelta_male = c(-2.7, 0.5),
prior_logsigma_immature = c(-3.05, 0.25),
prior_logsigma_female = c(-3.1, 0.2),
prior_logsigma_male = c(-3.1, 0.2)
)
LSI_multisite_model <- cmdstan_model("./Scripts/LSI_mixture_model_multisite.stan")
multisite_samples <- LSI_multisite_model$sample(
data = multisite_mixmod_standata,
chains = 4,
parallel_chains = 4,
refresh = 250,
adapt_delta = 0.80,
max_treedepth = 15
)
####Import the data (if necessary)####
#Import mixture model data. This script uses the results of the "data_cleaning.R" as an example
#Alternatively, you could run the script in the same R environment earlier so that the objects exist.
#IMPORTANT: To provide a basic structure of the data, this script uses two copies of the same data.
#That's not great practice!
#But it does show how to bring in data from multiple files (assuming you have them) and then assign
#Site_No code values.
site1_mixmod_data <- fread("./Data/Site Mixture Model Data.csv")
site1_demographic_observations <- fread("./Data/Site Demographic Observations.csv")
#
site2_mixmod_data <- fread("./Data/Site Mixture Model Data.csv")
site2_demographic_observations <- fread("./Data/Site Demographic Observations.csv")
#Combine the datasets and redefine codes (Specimen_No, Element_Portion, Measurement_Set)
nw_anatolian_mixmod_data <- rbind(
data.table(Site_No = 1, site1_mixmod_data),
data.table(Site_No = 2, site2_mixmod_data)
)
#Combine the datasets and redefine codes (Specimen_No, Element_Portion, Measurement_Set)
multisite_mixmod_data <- rbind(
data.table(Site_No = 1, site1_mixmod_data),
data.table(Site_No = 2, site2_mixmod_data)
)
#Re-assign numeric codes for element portions, measurement sets, and individual specimens (to prevent mismatches/overlap)
multisite_mixmod_data[, Measurement_Set := as.numeric(as.factor(Measurement))]
multisite_mixmod_data[, Element_Portion := as.numeric(as.factor(Element))]
multisite_mixmod_data[, .N, ID]
multisite_mixmod_data[, Specimen_No := as.numeric(as.factor(ID))] #this line needs to be different for the made-up example
multisite_mixmod_data[, .N, ID]
#Because I'm using two copies of the same site (again, don't do this!), need to include Site_No
#Normally this wouldn't be an issue, but is useful to know in case you have other circumstances that create identical IDs
multisite_mixmod_date[, Specimen_No := as.numeric(as.factor(paste(Site_No, ID, sep = ".")))]
#Because I'm using two copies of the same site (again, don't do this!), need to include Site_No
#Normally this wouldn't be an issue, but is useful to know in case you have other circumstances that create identical IDs
multisite_mixmod_data[, Specimen_No := as.numeric(as.factor(paste(Site_No, ID, sep = ".")))]
multisite_mixmod_data[, .N, Specimen_No]
67*2
#
multisite_demographic_observations <- rbind(
data.table(Site_No = 1, site1_demographic_observations),
data.table(Site_No = 2, site2_demographic_observations)
)
####Set up the data for the Stan model####
#Stan requires the data set up as a list object
#Multisite Analysis
multisite_mixmod_standata <- list(
#Sample sizes
N_Sites = multisite_mixmod_data[, .N, Site_No][, .N],
N_Specimens = multisite_mixmod_data[, .N, Specimen_No][, .N],
N_Measurements = multisite_mixmod_data[, .N],
N_Element_Portions = multisite_mixmod_data[, .N, Element_Portion][, .N],
N_Measurement_Sets = multisite_mixmod_data[, .N, Measurement_Set][, .N],
#Specimen observations
Site = multisite_mixmod_data[, .N, .(Specimen_No, Element_Portion, Site_No, Immature)][order(Specimen_No), Site_No],
Element_Portion = multisite_mixmod_data[, .N, .(Specimen_No, Element_Portion, Site_No, Immature)][order(Specimen_No), Element_Portion],
Immature = multisite_mixmod_data[, .N, .(Specimen_No, Element_Portion, Site_No, Immature)][order(Specimen_No), Immature],
Immature_Proportion = as.matrix(dcast(multisite_mixmod_data[, .(Immature_Proportion = mean(Immature)), .(Site_No, Element_Portion)], Site_No ~ Element_Portion, value.var = "Immature_Proportion", fill = 0))[, 2:(multisite_mixmod_data[, .N, Element_Portion][, .N] + 1)],
#Measurement observations
Measurement_obs = multisite_mixmod_data[, Measurement_value],
Measurement_sd = multisite_mixmod_data[, Measurement_value * 0.01], #Calculate measurement error for observed measurements and reference data (1% based on data from Breslawksi and Byers 2015)
Reference_obs = multisite_mixmod_data[, .N, .(Measurement_Set, Reference_value)][order(Measurement_Set), Reference_value],
Reference_sd = multisite_mixmod_data[, .N, .(Measurement_Set, Reference_value)][order(Measurement_Set), Reference_value * 0.01],
Measurement_Set = multisite_mixmod_data[, Measurement_Set],
Specimen = multisite_mixmod_data[, Specimen_No],
#Demographic observations
N_Immature_obs = multisite_demographic_observations[, .N],
Immature_obs_site = multisite_demographic_observations[, Site_No],
Immature_obs = multisite_demographic_observations[, N_Unfused],
Immature_obs_n = multisite_demographic_observations[, N_Ageable],
N_Female_obs = multisite_demographic_observations[, .N],
Female_obs_site = multisite_demographic_observations[, Site_No],
Female_obs = multisite_demographic_observations[, N_Female],
Female_obs_n = multisite_demographic_observations[, N_Sexable],
#Prior distributions for hyper-parameters
prior_theta_raw_1 = c(-0.5, 1.5),
prior_theta_raw_2 = c(0, 1.5),
prior_mu_female = c(0, 0.2),
prior_logdelta_immature = c(-3.5, 0.5),
prior_logdelta_male = c(-2.7, 0.5),
prior_logsigma_immature = c(-3.05, 0.25),
prior_logsigma_female = c(-3.1, 0.2),
prior_logsigma_male = c(-3.1, 0.2)
)
LSI_multisite_model <- cmdstan_model("./Scripts/LSI_mixture_model_multisite.stan")
multisite_samples <- LSI_multisite_model$sample(
data = multisite_mixmod_standata,
chains = 4,
parallel_chains = 4,
refresh = 250,
adapt_delta = 0.80,
max_treedepth = 15
)
#These are the names of the model hyper-parameters that were given user-defined prior distributions
multisite_samples$summary(c("grand_theta_raw",
"grand_mu_female", "grand_logdelta_immature", "grand_logdelta_male",
"grand_logsigma_immature", "grand_logsigma_female", "grand_logsigma_male"))
#This displays an estimate of the parameter for each site
multisite_samples$summary(c("site_mu_female"))
#This displays an estimate of the parameter for each site and element portion
multisite_samples$summary(c("mu_female"))
#Beyond summaries, it is also worth looking at trace plots that overlay each chain on top of one another
#To do this, first save the model fit into an rstan stanfit object
multisite_stanfit <- rstan::read_stan_csv(multisite_samples$output_files())
#Then use the convenient plotting function for a defined variable
traceplot(multisite_stanfit, c("grand_theta_raw",
"grand_mu_female", "grand_logdelta_immature", "grand_logdelta_male",
"grand_logsigma_immature", "grand_logsigma_female", "grand_logsigma_male"))
#
traceplot(multisite_stanfit, "site_mu_female")
#
traceplot(multisite_stanfit, "mu_female")
#IMPORTANT: To ensure reproducibility, you can also extract the random seed used to generate your model
#and then place the seed in the samples call using the argument
#seed = [whatever number you were given]
get_seed(multisite_stanfit)
?melt
full_assemblage
measured_assemblage <- site_mixmod_data[, .N, .(ID, Site, Specimen_No, Element, Element_Portion, Immature)]
#here, the "N" variable is the number of observed measurements the specimen has
#Create the modeled assemblage
#if data are set up in the EOL format, this is simply done by removing measurement variables from the original
#line that created the measurement assemblage
modeled_assemblage <- dataset[`Has Biological Taxonomy [Label]` %in% c(modeled_taxon) & `Has anatomical identification [Label]` %in% c(modeled_elements, extra_element_names),
.(ID = paste("Barcin", `Label`, sep = " "),
#I have separated these columns into separate lines to make it easier to read, but this is not necessary
#NOTE: if running a multisite analysis, I find it helpful to append the site name to whatever label the
#specimen has to ensure that there are no repeated labels across different sites
Site = "Barcin",
Taxon = `Has Biological Taxonomy [Label]`,
Anatomy = `Has anatomical identification [Label]`,
`Proximal Fusion` = `Has fusion character [Proximal Label]`,
`Distal Fusion` = `Has fusion character [Distal Label]`)]
#The next step is to align the "Specimen_No" variable for the specimens with measurements
#and leave it as NA (missing value) for non-measured specimens.
#This is done by using a "join"
modeled_assemblage <- measured_assemblage[, .(ID, Specimen_No, Element_Portion, Element, Immature)][modeled_assemblage, on = "ID"]
#The final step is to assign the Element_Portion and Immature variables for all non-measured specimens.
#These must be the same codes as used in the original model (as they impact what parameter values are used)
#These codes are part of the assemblage_restructure() function
for(i in 1:site_element_key[, .N]) {
modeled_assemblage[is.na(Element_Portion) & Anatomy %in% site_element_key[i, `Anatomy Label`], Element := site_element_key[i, `Element Label`]]
#Separate out proximal and distal element portions based on presence of later-fusing measurements (e.g., radius bone is proximal/distal based on presence of Bd measurement)
if(site_element_key[i, `Element Label`] %in% c("Rad", "Mtc", "Fem", "Mtt")) {
modeled_assemblage[is.na(Element_Portion) & Anatomy %in% site_element_key[i, `Anatomy Label`], Element := ifelse(`Distal Fusion` %in% "" == F, paste(site_element_key[i, `Element Label`], "dist", sep = "_"), paste(site_element_key[i, `Element Label`], "prox", sep = "_"))]
}
if(site_element_key[i, `Element Label`] %in% c("Tib")) {
modeled_assemblage[is.na(Element_Portion) & Anatomy %in% site_element_key[i, `Anatomy Label`], Element := ifelse(`Proximal Fusion` %in% "" == F, paste(site_element_key[i, `Element Label`], "prox", sep = "_"), paste(site_element_key[i, `Element Label`], "dist", sep = "_"))]
}
}
#Troubleshooting: remove unobserved element portions from modeled assemblage
#This is in case there were element portions in the original modeled set
#that had no actual measurements (e.g., if there were no measured Distal Radius specimens).
#Since we don't have element portion-specific parameter estimates for that element,
#we cannot considered it part of the "modeled" assemblage
#This is again done by a join
modeled_assemblage <- measured_assemblage[, .N, .(Element_Portion, Element)][, .(Element_Portion, Element)][modeled_assemblage, on = "Element"][!is.na(Element_Portion)]
#Get the Immature variable (potentially immature status based on fusion/tooth eruption)
#This is only assigning Immature status for non-measured specimens
#Measured specimens had their Immature status drawn from the site_mixmod_data records
#(in case Immature values were changed through troubleshooting)
modeled_assemblage[is.na(Immature) & Element %in% c("Sca", "Ast"), Immature := 1] #does not fuse / subject to post-fusion growth and has no relevant fusion data to exclude immature status
modeled_assemblage[is.na(Immature) & Element %in% c("Hum", "Cal", "PH1"), Immature := as.numeric(`Proximal Fusion` %in% c("Proximal epiphysis fused", "Proximal epiphysis fusing") == F)]
modeled_assemblage[is.na(Immature) & Element %in% c("Rad_prox", "Rad_dist", "Mtc_prox", "Mtc_dist", "Mtt_prox", "Mtt_dist"), Immature := as.numeric(`Distal Fusion` %in% c("Distal epiphysis fused", "Distal epiphysis fusing") == F)]
modeled_assemblage[is.na(Immature) & Element %in% c("Fem_prox", "Fem_dist", "Tib_prox", "Tib_dist"), Immature := as.numeric((`Proximal Fusion` %in% c("Proximal epiphysis fused", "Proximal epiphysis fusing") | `Distal Fusion` %in% c("Distal epiphysis fused", "Distal epiphysis fusing")) == F)]
####Collecting the "full" assemblage####
#The same logic that underpins the estimation of a "modeled" assemblage can be extended to element portions
#that had no observed measurements at all (a "full" assemblage). This is useful for extending an analysis
#to element portions (parts of the body that you want to study) that either do not have standard breadth
#measurements or did not have any observed measurements but you want to model them directly anyway.
#First, define the additional elements (and the associated "element portion" labels you want to use)
additional_elements <- c("innominate bone", "ulna") #same naming convention as the original elements
additional_element_labels <- c("Pel", "Uln") #IMPORTANT! Make sure that the order is the same across both
#Expand the element key to create new element labels
site_full_element_key <- rbind(site_element_key,
data.table(`Anatomy Label` = additional_elements, `Element Label` = additional_element_labels))
#Second, create the full assemblage
#if data are set up in the EOL format, this is simply done by removing measurement variables from the original
#line that created the measurement assemblage and
#adding additional_elements to the filter on `Has anatomical identification [Label]`
full_assemblage <- dataset[`Has Biological Taxonomy [Label]` %in% c(modeled_taxon) & `Has anatomical identification [Label]` %in% c(modeled_elements, extra_element_names, additional_elements),
.(ID = paste("Barcin", `Label`, sep = " "),
#I have separated these columns into separate lines to make it easier to read, but this is not necessary
#NOTE: if running a multisite analysis, I find it helpful to append the site name to whatever label the
#specimen has to ensure that there are no repeated labels across different sites
Site = "Barcin",
Taxon = `Has Biological Taxonomy [Label]`,
Anatomy = `Has anatomical identification [Label]`,
`Proximal Fusion` = `Has fusion character [Proximal Label]`,
`Distal Fusion` = `Has fusion character [Distal Label]`)]
#The rest of the formatting is largely the same as with the modeled assemblage, though including the additional elements
#Some troubleshooting may be necessary to include the right mix of additional elements you want to include
#The next step is to align the "Specimen_No" variable for the specimens with measurements
#and leave it as NA (missing value) for non-measured specimens.
#This is done by using a "join"
full_assemblage <- measured_assemblage[, .(ID, Specimen_No, Element_Portion, Element, Immature)][full_assemblage, on = "ID"]
#The final step is to assign the Element_Portion and Immature variables for all non-measured specimens.
#These must be the same codes as used in the original model (as they impact what parameter values are used)
#These codes are part of the assemblage_restructure() function
for(i in 1:site_full_element_key[, .N]) {
full_assemblage[is.na(Element_Portion) & Anatomy %in% site_full_element_key[i, `Anatomy Label`], Element := site_full_element_key[i, `Element Label`]]
#Separate out proximal and distal element portions based on presence of later-fusing measurements (e.g., radius bone is proximal/distal based on presence of Bd measurement)
if(site_full_element_key[i, `Element Label`] %in% c("Rad", "Mtc", "Fem", "Mtt")) {
full_assemblage[is.na(Element_Portion) & Anatomy %in% site_full_element_key[i, `Anatomy Label`], Element := ifelse(`Distal Fusion` %in% "" == F, paste(site_full_element_key[i, `Element Label`], "dist", sep = "_"), paste(site_full_element_key[i, `Element Label`], "prox", sep = "_"))]
}
if(site_full_element_key[i, `Element Label`] %in% c("Tib")) {
full_assemblage[is.na(Element_Portion) & Anatomy %in% site_full_element_key[i, `Anatomy Label`], Element := ifelse(`Proximal Fusion` %in% "" == F, paste(site_full_element_key[i, `Element Label`], "prox", sep = "_"), paste(site_full_element_key[i, `Element Label`], "dist", sep = "_"))]
}
}
#Assign element portion numbers (matching original measured assemblage)
#Unlike the modeled assemblage, we don't want to remove element portions without any observed measurements.
#We do, however, want to keep the same Element_Portion labels for those element portions WITH observed measurements,
#then add new labels for the unobserved element portions
#This is again done by a join
full_assemblage <- measured_assemblage[, .N, .(Element_Portion, Element)][, .(Element_Portion, Element)][full_assemblage, on = "Element"]
#Defining the new Element_Portion labels will be done here alphabetically by "Element" label (among unobserved element portions)
unobserved_element_portions <- full_assemblage[is.na(Element_Portion), .N, Element][order(Element), Element]
for(i in 1:length(unobserved_element_portions)) {
full_assemblage[Element %in% unobserved_element_portions[i], Element_Portion := (measured_assemblage[, .N, Element_Portion][, .N] + i)]
}
#Get the Immature variable (potentially immature status based on fusion/tooth eruption)
#This is only assigning Immature status for non-measured specimens
#Measured specimens had their Immature status drawn from the site_mixmod_data records
#(in case Immature values were changed through troubleshooting)
full_assemblage[is.na(Immature) & Element %in% c("Sca", "Ast"), Immature := 1] #does not fuse / subject to post-fusion growth and has no relevant fusion data to exclude immature status
full_assemblage[is.na(Immature) & Element %in% c("Hum", "Cal", "PH1"), Immature := as.numeric(`Proximal Fusion` %in% c("Proximal epiphysis fused", "Proximal epiphysis fusing") == F)]
full_assemblage[is.na(Immature) & Element %in% c("Rad_prox", "Rad_dist", "Mtc_prox", "Mtc_dist", "Mtt_prox", "Mtt_dist"), Immature := as.numeric(`Distal Fusion` %in% c("Distal epiphysis fused", "Distal epiphysis fusing") == F)]
full_assemblage[is.na(Immature) & Element %in% c("Fem_prox", "Fem_dist", "Tib_prox", "Tib_dist"), Immature := as.numeric((`Proximal Fusion` %in% c("Proximal epiphysis fused", "Proximal epiphysis fusing") | `Distal Fusion` %in% c("Distal epiphysis fused", "Distal epiphysis fusing")) == F)]
#Codes for the additional elements (update for other lists of additional elements)
full_assemblage[is.na(Immature) & Element %in% c("Pel"), Immature := as.numeric((`Proximal Fusion` %in% c("Proximal epiphysis fused", "Proximal epiphysis fusing") | `Distal Fusion` %in% c("Distal epiphysis fused", "Distal epiphysis fusing")) == F)]
full_assemblage[is.na(Immature) & Element %in% c("Uln"), Immature := as.numeric((`Proximal Fusion` %in% c("Proximal epiphysis fused", "Proximal epiphysis fusing") | `Distal Fusion` %in% c("Distal epiphysis fused", "Distal epiphysis fusing")) == F)]
full_assemblage
modeled_assemblage
full_assemblage[, .N, Element_Portion][, .N]
measured_assemblage[, .N, Element_Portion][, .N]
full_assemblage[, .N, .(Element, Element_Portion)][Element_Portion > 11]
full_assemblage[, .N, .(Element, Element_Portion)][Element_Portion > 11][order(Element_Portion), Element_Portion]
full_assemblage[, .N, .(Element, Element_Portion)][Element_Portion > 11][order(Element_Portion), Element]
measured_assemblage[, .N, Element_Portion][, .N]
full_assemblage[, .N, .(Element, Element_Portion)][Element_Portion > measured_assemblage[, .N, Element_Portion][, .N]][order(Element_Portion), .N]
#Second, calculate the immature proportions for the three datasets (affects how heavily potentially-immature specimens are weighted towards that category)
measured_immature_proportions <- measured_assemblage[, .(Immature_Proportion = mean(Immature)), .(Portion = Element_Portion)][order(Portion)]
modeled_immature_proportions <- modeled_assemblage[, .(Immature_Proportion = mean(Immature)), .(Portion = Element_Portion)][order(Portion)]
full_immature_proportions <- full_assemblage[, .(Immature_Proportion = mean(Immature)), .(Portion = Element_Portion)][order(Portion)]
measured_immature_proportions
modeled_immature_proportions
full_immature_proportions
modeled_assemblage[, .(Immature_Proportion = mean(Immature)), .(Portion = Element_Portion)]
modeled_assemblage[Element_Portion %in% 8, .(Immature_Proportion = mean(Immature))]
modeled_assemblage[Element_Portion %in% 8, .(Immature_Proportion = sum(Immature))]
modeled_assemblage[Element_Portion %in% 8, .(Immature_Proportion = .N)]
modeled_assemblage[Element_Portion %in% 8, Immature]
modeled_assemblage[is.na(Immature)]
full_assemblage[is.na(Immature) & Element %in% c("Hum", "Cal", "PH1", "PH2"), Immature := as.numeric(`Proximal Fusion` %in% c("Proximal epiphysis fused", "Proximal epiphysis fusing") == F)]
modeled_assemblage[is.na(Immature) & Element %in% c("Hum", "Cal", "PH1", "PH2"), Immature := as.numeric(`Proximal Fusion` %in% c("Proximal epiphysis fused", "Proximal epiphysis fusing") == F)]
modeled_assemblage[is.na(Immature)]
modeled_assemblage[Element_Portion %in% 8, .(Immature_Proportion = sum(Immature))]
modeled_assemblage[, .(Immature_Proportion = mean(Immature)), .(Portion = Element_Portion)][order(Portion)]
#Second, calculate the immature proportions for the three datasets (affects how heavily potentially-immature specimens are weighted towards that category)
measured_immature_proportions <- measured_assemblage[, .(Immature_Proportion = mean(Immature)), .(Portion = Element_Portion)][order(Portion)]
modeled_immature_proportions <- modeled_assemblage[, .(Immature_Proportion = mean(Immature)), .(Portion = Element_Portion)][order(Portion)]
full_immature_proportions <- full_assemblage[, .(Immature_Proportion = mean(Immature)), .(Portion = Element_Portion)][order(Portion)]
full_immature_proportions
modeled_immature_proportions
library("doParallel")
library("parallel")
####Simulate the composition####
#Ideally, you will use parallel computing to do this much faster (using the doParallel and parallel packages)
#To do this, you need to assign different cores on your computer to a cluster (this is necessary for Windows, but should work on all platforms)
#setting resources to do simulations with multicore processing (on Windows)
num_cores <- detectCores(logical = T)
cl <- makeCluster(num_cores - 4) #creating a virtual cluster
registerDoParallel(cl) #registering the cluster
#Then export the objects, packages, and functions to the virtual cluster
clusterExport(cl, list('data.table', 'melt', 'ifm_sample', 'theta_finder', 'ifm_composition', 'measured_assemblage', 'measured_immature_proportions', 'modeled_assemblage', 'modeled_immature_proportions', 'full_assemblage', 'full_immature_proportions', 'single_assemblage_post', 'site_unmodeled_element_portion_theta'))
#Simulate a specimen as Immature/Female/Male based on probabilities
ifm_sample <- function(p_immature, p_female, p_male) {
sample(c("Immature", "Female", "Male"), 1, replace = T, prob = c(p_immature, p_female, p_male))
}
#Identifies the correct set of Immature/Female/Male probabilities for a specimen based on whether it was directly modeled
#and the element portion that it is
theta_finder <- function(Specimen_No, Element_Portion, Immature, Immature_Proportions, element_thetas, specimen_probs) {
thetas <- rep(NA, 3)
immature_proportion <- Immature_Proportions[Portion %in% Element_Portion, Immature_Proportion]
thetas[1:3] <- ifelse(rep(!is.na(Specimen_No), 3),
specimen_probs[Specimen_No, 1:3],
ifelse(rep(Immature == 1, 3),
c(element_thetas[1, Element_Portion] / immature_proportion,
element_thetas[2, Element_Portion] * immature_proportion,
element_thetas[3, Element_Portion] * immature_proportion),
c(0,
element_thetas[2, Element_Portion] / (1 - min(c(element_thetas[1, Element_Portion], 0.99999))), #fail-safe for extreme values
element_thetas[3, Element_Portion] / (1 - min(c(element_thetas[1, Element_Portion], 0.99999)))))
)
list(p_immature = thetas[1] / sum(thetas), p_female = thetas[2] / sum(thetas), p_male = thetas[3] / sum(thetas))
}
#Simulates the composition of an assemblage with Immature/Female/Male probabilities
ifm_composition <- function(measured_specimens) {
#simulate sex assignments
measured_specimens[, Simulated_Group := sapply(1:.N, function(x) ifm_sample(p_immature[x], p_female[x], p_male[x]))]
#counts of the different elements by group (make sure there's a 0 if a value is missing)
melt(measured_specimens[, .(`Immature` = sum(Simulated_Group %in% "Immature"),
`Female` = sum(Simulated_Group %in% "Female"),
`Male` = sum(Simulated_Group %in% "Male")), .(Site_No, Element_Portion, Element)], id.vars = c("Site_No", "Element_Portion", "Element"), variable.name = "Simulated_Group", value.name = "N")[order(Site_No, Element_Portion, Simulated_Group)]
}
#Simulates the fusion rate of an assemblage with Immature/Female/Male probabilities
ifm_fusion_rate <- function(measured_specimens) {
#simulate sex assignments
measured_specimens[, Simulated_Group := sapply(1:.N, function(x) ifm_sample(p_immature[x], p_female[x], p_male[x]))]
#counts of the different elements by group and fusion status
melt(measured_specimens[, .(`Immature` = sum(Simulated_Group %in% "Immature"),
`Female` = sum(Simulated_Group %in% "Female"),
`Male` = sum(Simulated_Group %in% "Male")), .(Site_No, Fusion_Element, Stage, Fusion)], id.vars = c("Site_No", "Fusion_Element", "Stage", "Fusion"), variable.name = "Simulated_Group", value.name = "N")[order(Site_No, Stage, Fusion_Element, Fusion, Simulated_Group)]
}
#Plots the distributions of group-specific composition estimates
composition_analysis <- function(composition_data, site_no = 1, site_name = "Site Measured Assemblage", full_element_name_key = site_element_name_key) {
ggplot(composition_data[Site_No %in% site_no, .(N = sum(N)), .(Iteration, Simulated_Group, Element, Element_Portion)][, .(Element, Element_Portion, group = Simulated_Group, Plot_Group = paste(Element, as.numeric(Simulated_Group), sep = "."), N)]) + aes(y = N, x = Plot_Group) +
stat_slab(normalize = "groups", slab_type = "histogram", breaks = 0:(composition_data[Site_No %in% site_no, .(N = sum(N)), .(Iteration, Simulated_Group, Element, Element_Portion)][, max(N)]), aes(fill = group, fill_ramp = stat(cut_cdf_qi(cdf, .width = c(0.80, 0.95, 1), labels = scales::percent_format())))) +
stat_pointinterval(.width = c(0.8, 0.95), aes(color = group), position = position_dodge(width = 0.2, preserve = "single")) +
scale_fill_ramp_discrete(name = "Interval", range = c(0.5, 0.15), na.translate = F) +
scale_color_manual(name = "Group", values = c("black", "blue", "red"), na.translate = F) +
scale_fill_manual(name = "Group", values = c("black", "blue", "red"), na.translate = F) +
scale_x_discrete(name = "Element", breaks = composition_data[, .N, .(Element, Element_Portion)][order(Element_Portion), paste(Element, ".2", sep = "")], labels = composition_data[, .N, .(Element, Element_Portion)][full_element_name_key, on = "Element"][!is.na(Element_Portion)][order(Element_Portion), Full_Element_Name]) +
scale_y_continuous(name = "Estimated Count", breaks = integer_breaks()) + coord_cartesian(expand = FALSE) +
labs(title = site_name) +
theme_classic() + theme(legend.text = element_text(size = 10), legend.position = "bottom", legend.justification = c("center"), legend.box.just = "right", legend.margin = margin(6, 6, 6, 6), axis.text.x = element_text(size = 8, angle = -90, hjust = 0), axis.title = element_text(size = 12), axis.text.y = element_text(size = 8), axis.title.x = element_blank())
}
#First, calculate new sets of element_portion-specific mixing probabilities for unmodeled element portions (for full assemblage)
site_unmodeled_element_portion_theta <- data.table(Iteration = rep(1:4000, full_assemblage[, .N, .(Element, Element_Portion)][Element_Portion > measured_assemblage[, .N, Element_Portion][, .N]][order(Element_Portion), .N]),
Element_Portion = rep(full_assemblage[, .N, .(Element, Element_Portion)][Element_Portion > measured_assemblage[, .N, Element_Portion][, .N]][order(Element_Portion), Element_Portion], each = 4000),
Element = rep(full_assemblage[, .N, .(Element, Element_Portion)][Element_Portion > measured_assemblage[, .N, Element_Portion][, .N]][order(Element_Portion), Element], each = 4000))
#specify hyper-parameter values for the model
for(i in 1:full_assemblage[, .N, .(Element, Element_Portion)][Element_Portion > measured_assemblage[, .N, Element_Portion][, .N]][order(Element_Portion), .N]) {
element_theta_raw <- t(sapply(1:4000, function(x) MASS::mvrnorm(1, mu = single_assemblage_post$grand_theta_raw[x, 1:2], Sigma = diag(single_assemblage_post$element_sigma[x, 1:2]) %*% single_assemblage_post$Rho_element[x, 1:2, 1:2] %*% diag(single_assemblage_post$element_sigma[x, 1:2]))))
site_unmodeled_element_portion_theta[(4000 * (i - 1) + 1):(4000 * i), c("theta_raw_1", "theta_raw_2") := .(element_theta_raw[, 1], element_theta_raw[, 2])]
}
#perform stick-breaking procedure to turn theta_raw into theta values
site_unmodeled_element_portion_theta[, theta_1 := boot::inv.logit(theta_raw_1 + log(0.5))]
site_unmodeled_element_portion_theta[, theta_2 := (1 - theta_1) * boot::inv.logit(theta_raw_2 + log(1))]
site_unmodeled_element_portion_theta[, theta_3 := (1 - (theta_1 + theta_2))]
#Second, calculate the immature proportions for the three datasets (affects how heavily potentially-immature specimens are weighted towards that category)
measured_immature_proportions <- measured_assemblage[, .(Immature_Proportion = mean(Immature)), .(Portion = Element_Portion)][order(Portion)]
modeled_immature_proportions <- modeled_assemblage[, .(Immature_Proportion = mean(Immature)), .(Portion = Element_Portion)][order(Portion)]
full_immature_proportions <- full_assemblage[, .(Immature_Proportion = mean(Immature)), .(Portion = Element_Portion)][order(Portion)]
####Simulate the composition####
#Ideally, you will use parallel computing to do this much faster (using the doParallel and parallel packages)
#To do this, you need to assign different cores on your computer to a cluster (this is necessary for Windows, but should work on all platforms)
#setting resources to do simulations with multicore processing (on Windows)
num_cores <- detectCores(logical = T)
cl <- makeCluster(num_cores - 4) #creating a virtual cluster
registerDoParallel(cl) #registering the cluster
#Then export the objects, packages, and functions to the virtual cluster
clusterExport(cl, list('data.table', 'melt', 'ifm_sample', 'theta_finder', 'ifm_composition', 'measured_assemblage', 'measured_immature_proportions', 'modeled_assemblage', 'modeled_immature_proportions', 'full_assemblage', 'full_immature_proportions', 'single_assemblage_post', 'site_unmodeled_element_portion_theta'))
#Finally, run the simulations. This may take time, you can use a package like beepr::beep() to have the computer play a chime when it is done
measured_assemblage_simulated_composition <- rbindlist(parLapply(cl = cl, 1:4000, fun = function(x) ifm_composition(measured_assemblage[, theta_finder(Specimen_No, Element_Portion, Immature, measured_immature_proportions, element_thetas = single_assemblage_post$theta[x, , ], specimen_probs = single_assemblage_post$specimen_prob[x, , ]), .(ID, Specimen_No, Element, Element_Portion, Immature)][, .(ID, Specimen_No, Site_No = 1, Element, Element_Portion, Immature, p_immature, p_female, p_male)])[, .(Iteration = x, Site_No, Element_Portion, Element, Simulated_Group, N)]))
library("ggdist")
library("ggplot2")
library("ggpubr")
modeled_assemblage_simulated_composition <- rbindlist(parLapply(cl = cl, 1:4000, fun = function(x) ifm_composition(modeled_assemblage[, theta_finder(Specimen_No, Element_Portion, Immature, modeled_immature_proportions, element_thetas = single_assemblage_post$theta[x, , ], specimen_probs = single_assemblage_post$specimen_prob[x, , ]), .(ID, Specimen_No, Element, Element_Portion, Immature)][, .(ID, Specimen_No, Site_No = 1, Element, Element_Portion, Immature, p_immature, p_female, p_male)])[, .(Iteration = x, Site_No, Element_Portion, Element, Simulated_Group, N)]))
#
site_measured_composition
####Run the composition analyses####
#This saves each plot as an object, which can then be called to display the plot
#or combined together using the ggarrange() function
site_measured_composition <- composition_analysis(pinarbasi_measured_assemblage_simulated_composition, site_no = 1, site_name = "Measured Assemblage")
####Run the composition analyses####
#This saves each plot as an object, which can then be called to display the plot
#or combined together using the ggarrange() function
site_measured_composition <- composition_analysis(measured_assemblage_simulated_composition, site_no = 1, site_name = "Measured Assemblage")
#Third, this provides display names for the elements in the assemblages. Adjust as necessary:
#"Element" is the label for each Element_Portion
#"Full_Element_Name" is the name displayed in the composition plot
site_element_name_key <- data.table(
Element = c("Ast", "Cal", "Hum", "Mtc_dist", "Mtt_dist", "Mtt_prox", "PH1", "Rad_dist", "Tib_dist", "Tib_prox", "Rad_prox", "Mtc_prox", "Pel", "PH2", "Uln"),
Full_Element_Name = c("Astragalus", "Calcaneus", "Humerus", "D. Metacarpal", "D. Metatarsal", "P. Metatarsal", "Proximal Phalanx", "D. Radius", "D. Tibia", "P. Tibia", "P. Radius", "P. Metacarpal", "Pelvis", "Middle Phalanx", "Ulna")
)
####Run the composition analyses####
#This saves each plot as an object, which can then be called to display the plot
#or combined together using the ggarrange() function
site_measured_composition <- composition_analysis(measured_assemblage_simulated_composition, site_no = 1, site_name = "Measured Assemblage")
#function to get integer y-axis values only (source: https://gist.github.com/jhrcook/eb7b63cc57c683a6eb4986c4107a88ec)
integer_breaks <- function(n = 5, ...) {
fxn <- function(x) {
breaks <- floor(pretty(x, n, ...))
names(breaks) <- attr(breaks, "labels")
breaks
}
return(fxn)
}
####Run the composition analyses####
#This saves each plot as an object, which can then be called to display the plot
#or combined together using the ggarrange() function
site_measured_composition <- composition_analysis(measured_assemblage_simulated_composition, site_no = 1, site_name = "Measured Assemblage")
site_modeled_composition <- composition_analysis(modeled_assemblage_simulated_composition, site_no = 1, site_name = "Modeled Assemblage")
site_full_composition <- composition_analysis(full_assemblage_simulated_composition, site_no = 1, site_name = "Full Assemblage")
#
site_measured_composition
site_modeled_composition
warnings()
full_assemblage_simulated_composition <- rbindlist(parLapply(cl = cl, 1:4000, fun = function(x) ifm_composition(full_assemblage[, theta_finder(Specimen_No, Element_Portion, Immature, full_immature_proportions, element_thetas = cbind(single_assemblage_post$theta[x, , ], t(site_unmodeled_element_portion_theta[Iteration %in% x, .(theta_1, theta_2, theta_3)])), specimen_probs = single_assemblage_post$specimen_prob[x, , ]), .(ID, Specimen_No, Element, Element_Portion, Immature)][, .(ID, Specimen_No, Site_No = 1, Element, Element_Portion, Immature, p_immature, p_female, p_male)])[, .(Iteration = x, Site_No, Element_Portion, Element, Simulated_Group, N)]))
site_full_composition <- composition_analysis(full_assemblage_simulated_composition, site_no = 1, site_name = "Full Assemblage")
full_assemblage_simulated_composition
full_assemblage_simulated_composition[, .N, Element]
site_element_name_key
#Third, this provides display names for the elements in the assemblages. Adjust as necessary:
#"Element" is the label for each Element_Portion
#"Full_Element_Name" is the name displayed in the composition plot
site_element_name_key <- data.table(
Element = c("Ast", "Cal", "Hum", "Mtc_dist", "Mtt_dist", "Mtt_prox", "PH1", "Rad_dist", "Fem_prox", "Fem_dist", "Tib_dist", "Tib_prox", "Rad_prox", "Mtc_prox", "Pel", "PH2", "Uln"),
Full_Element_Name = c("Astragalus", "Calcaneus", "Humerus", "P. Metacarpal", "D. Metacarpal", "D. Metatarsal", "P. Metatarsal", "Proximal Phalanx", "D. Radius", "P. Femur", "D. Femur", "D. Tibia", "P. Tibia", "P. Radius", "P. Metacarpal", "Pelvis", "Middle Phalanx", "Ulna")
)
#Third, this provides display names for the elements in the assemblages. Adjust as necessary:
#"Element" is the label for each Element_Portion
#"Full_Element_Name" is the name displayed in the composition plot
site_element_name_key <- data.table(
Element = c("Ast", "Cal", "Hum", "Mtc_prox", "Mtc_dist", "Mtt_dist", "Mtt_prox", "PH1", "Rad_dist", "Fem_prox", "Fem_dist", "Tib_dist", "Tib_prox", "Rad_prox", "Mtc_prox", "Pel", "PH2", "Uln"),
Full_Element_Name = c("Astragalus", "Calcaneus", "Humerus", "P. Metacarpal", "D. Metacarpal", "D. Metatarsal", "P. Metatarsal", "Proximal Phalanx", "D. Radius", "P. Femur", "D. Femur", "D. Tibia", "P. Tibia", "P. Radius", "P. Metacarpal", "Pelvis", "Middle Phalanx", "Ulna")
)
####Run the composition analyses####
#This saves each plot as an object, which can then be called to display the plot
#or combined together using the ggarrange() function
site_measured_composition <- composition_analysis(measured_assemblage_simulated_composition, site_no = 1, site_name = "Measured Assemblage")
site_modeled_composition <- composition_analysis(modeled_assemblage_simulated_composition, site_no = 1, site_name = "Modeled Assemblage")
site_full_composition <- composition_analysis(full_assemblage_simulated_composition, site_no = 1, site_name = "Full Assemblage")
site_modeled_composition
site_full_composition
composition_analysis(measured_assemblage_simulated_composition, site_no = 1, site_name = "Measured Assemblage")
measured_assemblage_simulated_composition[, .N, .(Element, Element_Portion)][site_element_name_key, on = "Element"][!is.na(Element_Portion)][order(Element_Portion), Full_Element_Name]
measured_assemblage_simulated_composition[, .N, .(Element, Element_Portion)]
site_element_name_key
#Third, this provides display names for the elements in the assemblages. Adjust as necessary:
#"Element" is the label for each Element_Portion
#"Full_Element_Name" is the name displayed in the composition plot
site_element_name_key <- data.table(
Element = c("Ast", "Cal", "Hum", "Mtc_prox", "Mtc_dist", "Mtt_dist", "Mtt_prox", "PH1", "Rad_dist", "Fem_prox", "Fem_dist", "Tib_dist", "Tib_prox", "Rad_prox", "Pel", "PH2", "Uln"),
Full_Element_Name = c("Astragalus", "Calcaneus", "Humerus", "P. Metacarpal", "D. Metacarpal", "D. Metatarsal", "P. Metatarsal", "Proximal Phalanx", "D. Radius", "P. Femur", "D. Femur", "D. Tibia", "P. Tibia", "P. Radius", "Pelvis", "Middle Phalanx", "Ulna")
)
site_element_name_key
full_assemblage[, .N, .(Element)]
full_assemblage[, .N, .(Element)][order(Element)]
#Third, this provides display names for the elements in the assemblages. Adjust as necessary:
#"Element" is the label for each Element_Portion
#"Full_Element_Name" is the name displayed in the composition plot
site_element_name_key <- data.table(
Element = c("Ast", "Cal", "Sca", "Hum", "Mtc_prox", "Mtc_dist", "Mtt_dist", "Mtt_prox", "PH1", "Rad_dist", "Fem_prox", "Fem_dist", "Tib_dist", "Tib_prox", "Rad_prox", "Pel", "PH2", "Uln"),
Full_Element_Name = c("Astragalus", "Calcaneus", "Scapula", "Humerus", "P. Metacarpal", "D. Metacarpal", "D. Metatarsal", "P. Metatarsal", "Proximal Phalanx", "D. Radius", "P. Femur", "D. Femur", "D. Tibia", "P. Tibia", "P. Radius", "Pelvis", "Middle Phalanx", "Ulna")
)
####Run the composition analyses####
#This saves each plot as an object, which can then be called to display the plot
#or combined together using the ggarrange() function
site_measured_composition <- composition_analysis(measured_assemblage_simulated_composition, site_no = 1, site_name = "Measured Assemblage")
site_modeled_composition <- composition_analysis(modeled_assemblage_simulated_composition, site_no = 1, site_name = "Modeled Assemblage")
site_full_composition <- composition_analysis(full_assemblage_simulated_composition, site_no = 1, site_name = "Full Assemblage")
#
site_measured_composition
#Putting the figures together into a single figure
site_composition_figure <- ggarrange(site_measured_composition,
site_modeled_composition,
site_full_composition,
nrow = 3, ncol = 1, common.legend = T, legend = "bottom")
#
final_figure <- annotate_figure(site_composition_figure, top = text_grob("Estimated Composition of Site Cattle", face = "bold", size = 14))
#
final_figure
