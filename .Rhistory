N_Specimens = multisite_mixmod_data[, .N, Specimen_No][, .N],
N_Measurements = multisite_mixmod_data[, .N],
N_Element_Portions = multisite_mixmod_data[, .N, Element_Portion][, .N],
N_Dimensions = multisite_mixmod_data[, .N, Dimension][, .N],
#Specimen observations
Site = multisite_mixmod_data[, .N, .(Specimen_No, Element_Portion, Site_No, Immature)][order(Specimen_No), Site_No],
Element_Portion = multisite_mixmod_data[, .N, .(Specimen_No, Element_Portion, Site_No, Immature)][order(Specimen_No), Element_Portion],
Immature = multisite_mixmod_data[, .N, .(Specimen_No, Element_Portion, Site_No, Immature)][order(Specimen_No), Immature],
Immature_Proportion = as.matrix(dcast(multisite_mixmod_data[, .(Immature_Proportion = mean(Immature)), .(Site_No, Element_Portion)], Site_No ~ Element_Portion, value.var = "Immature_Proportion", fill = 0))[, 2:(multisite_mixmod_data[, .N, Element_Portion][, .N] + 1)],
#Measurement observations
Measurement_obs = multisite_mixmod_data[, Measurement_value],
Measurement_sd = multisite_mixmod_data[, Measurement_value * 0.01], #Calculate measurement error for observed measurements and reference data (1% based on data from Breslawksi and Byers 2015)
Reference_obs = multisite_mixmod_data[, .N, .(Dimension, Reference_value)][order(Dimension), Reference_value],
Reference_sd = multisite_mixmod_data[, .N, .(Dimension, Reference_value)][order(Dimension), Reference_value * 0.01],
Dimension = multisite_mixmod_data[, Dimension],
Specimen = multisite_mixmod_data[, Specimen_No],
#Demographic observations
N_Immature_obs = multisite_demographic_observations[, .N],
Immature_obs_site = multisite_demographic_observations[, Site_No],
Immature_obs = multisite_demographic_observations[, N_Unfused],
Immature_obs_n = multisite_demographic_observations[, N_Ageable],
N_Female_obs = multisite_demographic_observations[, .N],
Female_obs_site = multisite_demographic_observations[, Site_No],
Female_obs = multisite_demographic_observations[, N_Female],
Female_obs_n = multisite_demographic_observations[, N_Sexable],
#Prior distributions for hyper-parameters
prior_theta_raw_1 = c(-0.5, 1.5),
prior_theta_raw_2 = c(0, 1.5),
prior_mu_female = c(0, 0.2),
prior_logdelta_immature = c(-3.5, 0.5),
prior_logdelta_male = c(-2.7, 0.2),
prior_logsigma_immature = c(-3.05, 0.1),
prior_logsigma_female = c(-3.1, 0.1),
prior_logsigma_male = c(-3.1, 0.1)
)
LSI_multisite_model <- cmdstan_model("./Scripts/LSI_mixture_model_multisite.stan")
multisite_samples <- LSI_multisite_model$sample(
data = multisite_mixmod_standata,
chains = 4,
parallel_chains = 4,
refresh = 250,
adapt_delta = 0.80,
seed = 1099252793,
max_treedepth = 15
)
multisite_samples <- LSI_multisite_model$sample(
data = multisite_mixmod_standata,
chains = 1,
parallel_chains = 4,
refresh = 250,
adapt_delta = 0.80,
seed = 1099252793,
max_treedepth = 15
)
LSI_multisite_model <- cmdstan_model("./Scripts/LSI_mixture_model_multisite.stan")
multisite_samples <- LSI_multisite_model$sample(
data = multisite_mixmod_standata,
chains = 4,
parallel_chains = 4,
refresh = 250,
adapt_delta = 0.80,
seed = 1099252793,
max_treedepth = 15
)
multisite_stanfit <- rstan::read_stan_csv(multisite_samples$output_files())
multisite_post <- extract(multisite_stanfit)
rstan::stan_version()
rstan:::rstudio_stanc("Scripts/LSI_mixture_model_singlesite.stan")
rstan:::rstudio_stanc("Scripts/LSI_mixture_model_singlesite.stan")
rstan:::rstudio_stanc("Scripts/LSI_mixture_model_singlesite.stan")
rstan:::rstudio_stanc("Scripts/LSI_mixture_model_multisite.stan")
rstan:::rstudio_stanc("Scripts/LSI_known_specimens.stan")
####Load the packages####
#These packages are necessary for the script. Use the following line (without the comment #) to install
#the packages if you have not already installed them:
#install.packages("data.table", "cmdstanr", "rstan")
#For "cmdstanr", see the following installation instructions: https://mc-stan.org/cmdstanr/articles/cmdstanr.html
#For "rstan", see the following installation instructions: https://github.com/stan-dev/rstan/wiki/RStan-Getting-Started
#In general, you will need to install rtools to have a C++ toolchain; the above links help provide steps to do so.
library("cmdstanr")
library("data.table")
library("rstan")
####Import the data (if necessary)####
#Import mixture model data. This script uses the results of the "data_cleaning.R" as an example
#Alternatively, you could run the script in the same R environment earlier so that the objects exist
#If you do this, you need to use the following lines (uncommented)
#single_assemblage_mixmod_data <- site_mixmod_data
#single_assemblage_demographic_observations <- site_demographic_observations
single_assemblage_mixmod_data <- fread("./Data/Site Mixture Model Data.csv")
single_assemblage_demographic_observations <- fread("./Data/Site Demographic Observations.csv")
#Add Site_No category to mixmod data (used in defining the immature proportions)
#This variable isn't included in the data_cleaning script
single_assemblage_mixmod_data[, Site_No := 1]
####Set up the data for the Stan model####
#Stan requires the data set up as a list object
single_assemblage_mixmod_standata <- list(
#Sample sizes
N_Specimens = single_assemblage_mixmod_data[, .N, Specimen_No][, .N],
N_Measurements = single_assemblage_mixmod_data[, .N],
N_Element_Portions = single_assemblage_mixmod_data[, .N, Element_Portion][, .N],
N_Dimensions = single_assemblage_mixmod_data[, .N, Dimension][, .N],
#Specimen observations
Element_Portion = single_assemblage_mixmod_data[, .N, .(Specimen_No, Element_Portion, Immature)][order(Specimen_No), Element_Portion],
Immature = single_assemblage_mixmod_data[, .N, .(Specimen_No, Element_Portion, Immature)][order(Specimen_No), Immature],
Immature_Proportion = as.matrix(dcast(single_assemblage_mixmod_data[, .(Immature_Proportion = mean(Immature)), .(Site_No, Element_Portion)], Site_No ~ Element_Portion, value.var = "Immature_Proportion", fill = 0))[, 2:(single_assemblage_mixmod_data[, .N, Element_Portion][, .N] + 1)],
#Measurement observations
Measurement_obs = single_assemblage_mixmod_data[, Measurement_value],
Measurement_sd = single_assemblage_mixmod_data[, Measurement_value * 0.01], #Calculate measurement error for observed measurements and reference data (1% based on data from Breslawksi and Byers 2015)
Reference_obs = single_assemblage_mixmod_data[, .N, .(Dimension, Reference_value)][order(Dimension), Reference_value],
Reference_sd = single_assemblage_mixmod_data[, .N, .(Dimension, Reference_value)][order(Dimension), Reference_value * 0.01],
Dimension = single_assemblage_mixmod_data[, Dimension],
Specimen = single_assemblage_mixmod_data[, Specimen_No],
#Demographic observations
Immature_obs = single_assemblage_demographic_observations[, N_Unfused],
Immature_obs_n = single_assemblage_demographic_observations[, N_Ageable],
Female_obs = single_assemblage_demographic_observations[, N_Female],
Female_obs_n = single_assemblage_demographic_observations[, N_Sexable],
#Prior distributions for hyper-parameters
#These can be changed to reflect different scenarios
#They are largely based on the Shetland sheep population
prior_theta_raw_1 = c(-0.5, 1.5),
prior_theta_raw_2 = c(0, 1.5),
prior_mu_female = c(0, 0.1),
prior_logdelta_immature = c(-3.5, 0.4),
prior_logdelta_male = c(-2.7, 0.1),
prior_logsigma_immature = c(-3.05, 0.1),
prior_logsigma_female = c(-3.1, 0.1),
prior_logsigma_male = c(-3.1, 0.1)
)
singlesite_mixture_stanmodel <- cmdstan_model("./Scripts/LSI_mixture_model_singlesite.stan")
single_assemblage_samples <- singlesite_mixture_stanmodel$sample(
data = single_assemblage_mixmod_standata,
chains = 4,
parallel_chains = 4,
refresh = 250,
adapt_delta = 0.80,
max_treedepth = 15
)
#These are the names of the model hyper-parameters that were given user-defined prior distributions
single_assemblage_samples$summary(c("grand_theta_raw",
"grand_mu_female", "grand_logdelta_immature", "grand_logdelta_male",
"grand_logsigma_immature", "grand_logsigma_female", "grand_logsigma_male"))
#This displays an estimate of the parameter for each element portion
single_assemblage_samples$summary(c("mu_female"))
#Beyond summaries, it is also worth looking at trace plots that overlay each chain on top of one another
#Ideally, all of the chains should overlap each other and there shouldn't be any directionality across the
#length of the chains. This is sometimes called looking for "fuzzy caterpillars".
#To do this, first save the model fit into an rstan stanfit object
single_assemblage_stanfit <- rstan::read_stan_csv(single_assemblage_samples$output_files())
#Beyond summaries, it is also worth looking at trace plots that overlay each chain on top of one another
#Ideally, all of the chains should overlap each other and there shouldn't be any directionality across the
#length of the chains. This is sometimes called looking for "fuzzy caterpillars".
#To do this, first save the model fit into an rstan stanfit object
extract_samples <- function(fit_obj) {
vars <- fit_obj$metadata()$stan_variables
draws <- posterior::as_draws_rvars(fit_obj$draws())
lapply(vars, \(var_name){
posterior::draws_of(draws[[var_name]], with_chains = FALSE)
}) |> setNames(vars)
}
single_assemblage_stanfit <- extract_samples(single_assemblage_samples)
single_assemblage_post <- extract_samples(single_assemblage_samples)
single_assemblage_post$grand_theta_raw
str(single_assemblage_post$grand_theta_raw)
str(single_assemblage_post$mu_male)
bayesplot::mcmc_trace(single_assemblage_samples, pars = "grand_theta_raw")
bayesplot::mcmc_trace(single_assemblage_samples, pars = c("grand_theta_raw"))
bayesplot::mcmc_trace(single_assemblage_samples$draws, pars = c("grand_theta_raw"))
bayesplot::mcmc_trace(single_assemblage_samples$draws(pars = "grand_theta_raw"))
??mcmc_trace
bayesplot::mcmc_trace(single_assemblage_samples$draws(), pars = c("grand_theta_raw"))
bayesplot::mcmc_trace(single_assemblage_samples$draws(), regex_pars = c("grand_theta_raw"))
bayesplot::mcmc_trace(single_assemblage_samples$draws(), regex_pars = c("grand_theta_raw", "grand_mu_female"))
library("bayesplot")
library("ggplot2")
#Then use the convenient plotting function for a defined variable
grand_variable_names <- c("grand_theta_raw",
"grand_mu_female", "grand_logdelta_immature", "grand_logdelta_male",
"grand_logsigma_immature", "grand_logsigma_female", "grand_logsigma_male")
mcmc_trace(single_assemblage_samples$draws(), regex_pars = grand_variable_names)
#
mcmc_trace(single_assemblage_samples$draws(), regex_pars = "mu_female")
####Exporting the posterior distributions####
#For posterior analysis, you'll want to have the exact posterior estimates of the parameter values.
#These can be extracted from the cmdstanr object using a bespoke function
cmdstanr_extract_samples <- function(fit_obj) {
#credit to Andrew Johnson for this code (source: https://discourse.mc-stan.org/t/rstan-read-stan-csv-throwing-error-with-cmdstan-models-versions-2-35/35665/7)
vars <- fit_obj$metadata()$stan_variables
draws <- posterior::as_draws_rvars(fit_obj$draws())
lapply(vars, \(var_name){
posterior::draws_of(draws[[var_name]], with_chains = FALSE)
}) |> setNames(vars)
}
single_assemblage_post <- cmdstanr_extract_samples(single_assemblage_samples)
single_assemblage_samples$sampler_diagnostics()
str(single_assemblage_samples$sampler_diagnostics())
names(single_assemblage_samples)
single_assemblage_samples$runset
names(single_assemblage_samples)
single_assemblage_samples$initialize
names(single_assemblage_samples)
single_assemblage_samples$init
names(single_assemblage_samples)
single_assemblage_samples$seed
single_assemblage_samples$num_procs
single_assemblage_samples$grad_log_prob
single_assemblage_samples
single_assemblage_samples$inv_metric()
single_assemblage_samples$num_procs()
single_assemblage_samples$init()
single_assemblage_samples$initialize()
single_assemblage_samples$runset()
single_assemblage_samples$runset
single_assemblage_samples
names(single_assemblage_samples)
single_assemblage_samples$init_model_methods()
single_assemblage_samples$output_files()
single_assemblage_samples$output()
grep(single_assemblage_samples$output(), "seed")
grep("seed", single_assemblage_samples$output())
grepl("seed", single_assemblage_samples$output())
grep("seed", single_assemblage_samples$output()[[1]])
single_assemblage_samples$output()[[1]][grep("seed", single_assemblage_samples$output()[[1]])]
str_extract(single_assemblage_samples$output()[[1]][grep("seed", single_assemblage_samples$output()[[1]])], pattern = "[0-9]{1,}")
stringr::str_extract(single_assemblage_samples$output()[[1]][grep("seed", single_assemblage_samples$output()[[1]])], pattern = "[0-9]{1,}")
as.numeric(stringr::str_extract(single_assemblage_samples$output()[[1]][grep("seed", single_assemblage_samples$output()[[1]])], pattern = "[0-9]{1,}"))
#IMPORTANT: To ensure reproducibility, you can also extract the random seed used to generate your model
#and then place the seed in the samples call using the argument
#seed = [whatever number you were given]
get_seed <- function(cmdstan_object) {
string <- as.numeric(stringr::str_extract(cmdstan_object$output()[[1]][grep("seed", cmdstan_object$ouput()[[1]])], pattern = "[0-9]{1,}"))
string
}
get_seed(single_assemblage_samples)
#IMPORTANT: To ensure reproducibility, you can also extract the random seed used to generate your model
#and then place the seed in the samples call using the argument
#seed = [whatever number you were given]
get_seed <- function(cmdstan_object) {
string <- as.numeric(stringr::str_extract(cmdstan_object$output()[[1]][grep("seed", cmdstan_object$output()[[1]])], pattern = "[0-9]{1,}"))
string
}
get_seed(single_assemblage_samples)
as.numeric(stringr::str_extract(single_assemblage_samples$output()[[1]][grep("seed", single_assemblage_samples$output()[[1]])], pattern = "[0-9]{1,}"))
####Load the packages####
#These packages are necessary for the script. Use the following line (without the comment #) to install
#the packages if you have not already installed them:
#install.packages("data.table", "cmdstanr", "rstan", "ggplot2", "bayesplot")
#For "cmdstanr", see the following installation instructions: https://mc-stan.org/cmdstanr/articles/cmdstanr.html
#For "rstan", see the following installation instructions: https://github.com/stan-dev/rstan/wiki/RStan-Getting-Started
#In general, you will need to install rtools to have a C++ toolchain; the above links help provide steps to do so.
library("cmdstanr")
library("data.table")
# library("rstan")
library("ggplot2")
library("bayesplot")
####Import the data (if necessary)####
#Import mixture model data. This script uses the results of the "data_cleaning.R" as an example
#Alternatively, you could run the script in the same R environment earlier so that the objects exist
#If you do this, you need to use the following lines (uncommented)
#single_assemblage_mixmod_data <- site_mixmod_data
#single_assemblage_demographic_observations <- site_demographic_observations
single_assemblage_mixmod_data <- fread("./Data/Site Mixture Model Data.csv")
single_assemblage_demographic_observations <- fread("./Data/Site Demographic Observations.csv")
#Add Site_No category to mixmod data (used in defining the immature proportions)
#This variable isn't included in the data_cleaning script
single_assemblage_mixmod_data[, Site_No := 1]
####Set up the data for the Stan model####
#Stan requires the data set up as a list object
single_assemblage_mixmod_standata <- list(
#Sample sizes
N_Specimens = single_assemblage_mixmod_data[, .N, Specimen_No][, .N],
N_Measurements = single_assemblage_mixmod_data[, .N],
N_Element_Portions = single_assemblage_mixmod_data[, .N, Element_Portion][, .N],
N_Dimensions = single_assemblage_mixmod_data[, .N, Dimension][, .N],
#Specimen observations
Element_Portion = single_assemblage_mixmod_data[, .N, .(Specimen_No, Element_Portion, Immature)][order(Specimen_No), Element_Portion],
Immature = single_assemblage_mixmod_data[, .N, .(Specimen_No, Element_Portion, Immature)][order(Specimen_No), Immature],
Immature_Proportion = as.matrix(dcast(single_assemblage_mixmod_data[, .(Immature_Proportion = mean(Immature)), .(Site_No, Element_Portion)], Site_No ~ Element_Portion, value.var = "Immature_Proportion", fill = 0))[, 2:(single_assemblage_mixmod_data[, .N, Element_Portion][, .N] + 1)],
#Measurement observations
Measurement_obs = single_assemblage_mixmod_data[, Measurement_value],
Measurement_sd = single_assemblage_mixmod_data[, Measurement_value * 0.01], #Calculate measurement error for observed measurements and reference data (1% based on data from Breslawksi and Byers 2015)
Reference_obs = single_assemblage_mixmod_data[, .N, .(Dimension, Reference_value)][order(Dimension), Reference_value],
Reference_sd = single_assemblage_mixmod_data[, .N, .(Dimension, Reference_value)][order(Dimension), Reference_value * 0.01],
Dimension = single_assemblage_mixmod_data[, Dimension],
Specimen = single_assemblage_mixmod_data[, Specimen_No],
#Demographic observations
Immature_obs = single_assemblage_demographic_observations[, N_Unfused],
Immature_obs_n = single_assemblage_demographic_observations[, N_Ageable],
Female_obs = single_assemblage_demographic_observations[, N_Female],
Female_obs_n = single_assemblage_demographic_observations[, N_Sexable],
#Prior distributions for hyper-parameters
#These can be changed to reflect different scenarios
#They are largely based on the Shetland sheep population
prior_theta_raw_1 = c(-0.5, 1.5),
prior_theta_raw_2 = c(0, 1.5),
prior_mu_female = c(0, 0.1),
prior_logdelta_immature = c(-3.5, 0.4),
prior_logdelta_male = c(-2.7, 0.1),
prior_logsigma_immature = c(-3.05, 0.1),
prior_logsigma_female = c(-3.1, 0.1),
prior_logsigma_male = c(-3.1, 0.1)
)
singlesite_mixture_stanmodel <- cmdstan_model("./Scripts/LSI_mixture_model_singlesite.stan")
single_assemblage_samples <- singlesite_mixture_stanmodel$sample(
data = single_assemblage_mixmod_standata,
chains = 4,
parallel_chains = 4,
refresh = 250,
adapt_delta = 0.80,
max_treedepth = 15
)
#These are the names of the model hyper-parameters that were given user-defined prior distributions
single_assemblage_samples$summary(c("grand_theta_raw",
"grand_mu_female", "grand_logdelta_immature", "grand_logdelta_male",
"grand_logsigma_immature", "grand_logsigma_female", "grand_logsigma_male"))
#This displays an estimate of the parameter for each element portion
single_assemblage_samples$summary(c("mu_female"))
#Beyond summaries, it is also worth looking at trace plots that overlay each chain on top of one another
#Ideally, all of the chains should overlap each other and there shouldn't be any directionality across the
#length of the chains. This is sometimes called looking for "fuzzy caterpillars".
grand_variable_names <- c("grand_theta_raw",
"grand_mu_female", "grand_logdelta_immature", "grand_logdelta_male",
"grand_logsigma_immature", "grand_logsigma_female", "grand_logsigma_male")
mcmc_trace(single_assemblage_samples$draws(), regex_pars = grand_variable_names)
#
mcmc_trace(single_assemblage_samples$draws(), regex_pars = "mu_female")
####Exporting the posterior distributions####
#For posterior analysis, you'll want to have the exact posterior estimates of the parameter values.
#These can be extracted from the cmdstanr object using a bespoke function
cmdstanr_extract_samples <- function(fit_obj) {
#credit to Andrew Johnson for this code (source: https://discourse.mc-stan.org/t/rstan-read-stan-csv-throwing-error-with-cmdstan-models-versions-2-35/35665/7)
vars <- fit_obj$metadata()$stan_variables
draws <- posterior::as_draws_rvars(fit_obj$draws())
lapply(vars, \(var_name){
posterior::draws_of(draws[[var_name]], with_chains = FALSE)
}) |> setNames(vars)
}
single_assemblage_post <- cmdstanr_extract_samples(single_assemblage_samples)
#IMPORTANT: To ensure reproducibility, you can also extract the random seed used to generate your model
#and then place the seed in the samples call using the argument
#seed = [whatever number you were given]
get_seed <- function(cmdstan_object) {
string <- as.numeric(stringr::str_extract(cmdstan_object$output()[[1]][grep("seed", cmdstan_object$output()[[1]])], pattern = "[0-9]{1,}"))
string
}
get_seed(single_assemblage_samples)
####Import the data (if necessary)####
#Import mixture model data. This script uses the results of the "data_cleaning.R" as an example
#Alternatively, you could run the script in the same R environment earlier so that the objects exist.
#IMPORTANT: To provide a basic structure of the data, this script uses two copies of the same data.
#That's not great practice!
#But it does show how to bring in data from multiple files (assuming you have them) and then assign
#Site_No code values.
site1_mixmod_data <- fread("./Data/Site Mixture Model Data.csv")
site1_demographic_observations <- fread("./Data/Site Demographic Observations.csv")
#
site2_mixmod_data <- fread("./Data/Site Mixture Model Data.csv")
site2_demographic_observations <- fread("./Data/Site Demographic Observations.csv")
#Combine the datasets and redefine codes (Specimen_No, Element_Portion, Dimension)
multisite_mixmod_data <- rbind(
data.table(Site_No = 1, site1_mixmod_data),
data.table(Site_No = 2, site2_mixmod_data)
)
#Re-assign numeric codes for element portions, measurement sets, and individual specimens (to prevent mismatches/overlap)
multisite_mixmod_data[, Dimension := as.numeric(as.factor(Measurement))]
multisite_mixmod_data[, Element_Portion := as.numeric(as.factor(Element))]
multisite_mixmod_data[, Specimen_No := as.numeric(as.factor(ID))] #this line needs to be different for the made-up example
#Because I'm using two copies of the same site (again, don't do this!), need to include Site_No
#Normally this wouldn't be an issue, but is useful to know in case you have other circumstances that create identical IDs
multisite_mixmod_data[, Specimen_No := as.numeric(as.factor(paste(Site_No, ID, sep = ".")))]
#
multisite_demographic_observations <- rbind(
data.table(Site_No = 1, site1_demographic_observations),
data.table(Site_No = 2, site2_demographic_observations)
)
####Set up the data for the Stan model####
#Stan requires the data set up as a list object
#Multisite Analysis
multisite_mixmod_standata <- list(
#Sample sizes
N_Sites = multisite_mixmod_data[, .N, Site_No][, .N],
N_Specimens = multisite_mixmod_data[, .N, Specimen_No][, .N],
N_Measurements = multisite_mixmod_data[, .N],
N_Element_Portions = multisite_mixmod_data[, .N, Element_Portion][, .N],
N_Dimensions = multisite_mixmod_data[, .N, Dimension][, .N],
#Specimen observations
Site = multisite_mixmod_data[, .N, .(Specimen_No, Element_Portion, Site_No, Immature)][order(Specimen_No), Site_No],
Element_Portion = multisite_mixmod_data[, .N, .(Specimen_No, Element_Portion, Site_No, Immature)][order(Specimen_No), Element_Portion],
Immature = multisite_mixmod_data[, .N, .(Specimen_No, Element_Portion, Site_No, Immature)][order(Specimen_No), Immature],
Immature_Proportion = as.matrix(dcast(multisite_mixmod_data[, .(Immature_Proportion = mean(Immature)), .(Site_No, Element_Portion)], Site_No ~ Element_Portion, value.var = "Immature_Proportion", fill = 0))[, 2:(multisite_mixmod_data[, .N, Element_Portion][, .N] + 1)],
#Measurement observations
Measurement_obs = multisite_mixmod_data[, Measurement_value],
Measurement_sd = multisite_mixmod_data[, Measurement_value * 0.01], #Calculate measurement error for observed measurements and reference data (1% based on data from Breslawksi and Byers 2015)
Reference_obs = multisite_mixmod_data[, .N, .(Dimension, Reference_value)][order(Dimension), Reference_value],
Reference_sd = multisite_mixmod_data[, .N, .(Dimension, Reference_value)][order(Dimension), Reference_value * 0.01],
Dimension = multisite_mixmod_data[, Dimension],
Specimen = multisite_mixmod_data[, Specimen_No],
#Demographic observations
N_Immature_obs = multisite_demographic_observations[, .N],
Immature_obs_site = multisite_demographic_observations[, Site_No],
Immature_obs = multisite_demographic_observations[, N_Unfused],
Immature_obs_n = multisite_demographic_observations[, N_Ageable],
N_Female_obs = multisite_demographic_observations[, .N],
Female_obs_site = multisite_demographic_observations[, Site_No],
Female_obs = multisite_demographic_observations[, N_Female],
Female_obs_n = multisite_demographic_observations[, N_Sexable],
#Prior distributions for hyper-parameters
#These can be changed to reflect different scenarios
#They are largely based on the Shetland sheep population
prior_theta_raw_1 = c(-0.5, 1.5),
prior_theta_raw_2 = c(0, 1.5),
prior_mu_female = c(0, 0.2),
prior_logdelta_immature = c(-3.5, 0.5),
prior_logdelta_male = c(-2.7, 0.2),
prior_logsigma_immature = c(-3.05, 0.1),
prior_logsigma_female = c(-3.1, 0.1),
prior_logsigma_male = c(-3.1, 0.1)
)
LSI_multisite_model <- cmdstan_model("./Scripts/LSI_mixture_model_multisite.stan")
multisite_samples <- LSI_multisite_model$sample(
data = multisite_mixmod_standata,
chains = 4,
parallel_chains = 4,
refresh = 250,
adapt_delta = 0.80,
max_treedepth = 15
)
#These are the names of the model hyper-parameters that were given user-defined prior distributions
multisite_samples$summary(c("grand_theta_raw",
"grand_mu_female", "grand_logdelta_immature", "grand_logdelta_male",
"grand_logsigma_immature", "grand_logsigma_female", "grand_logsigma_male"))
#Beyond summaries, it is also worth looking at trace plots that overlay each chain on top of one another
#Ideally, all of the chains should overlap each other and there shouldn't be any directionality across the
#length of the chains. This is sometimes called looking for "fuzzy caterpillars".
grand_variable_names <- c("grand_theta_raw",
"grand_mu_female", "grand_logdelta_immature", "grand_logdelta_male",
"grand_logsigma_immature", "grand_logsigma_female", "grand_logsigma_male")
mcmc_trace(multisite_samples$draws(), regex_pars = grand_variable_names)
#
mcmc_trace(multisite_samples$draws(), regex_pars = "site_mu_female")
#
mcmc_trace(multisite_samples$draws(), regex_pars = "mu_female")
####Exporting the posterior distributions####
#For posterior analysis, you'll want to have the exact posterior estimates of the parameter values.
#These can be extracted from the cmdstanr object using a bespoke function
cmdstanr_extract_samples <- function(fit_obj) {
#credit to Andrew Johnson for this code (source: https://discourse.mc-stan.org/t/rstan-read-stan-csv-throwing-error-with-cmdstan-models-versions-2-35/35665/7)
vars <- fit_obj$metadata()$stan_variables
draws <- posterior::as_draws_rvars(fit_obj$draws())
lapply(vars, \(var_name){
posterior::draws_of(draws[[var_name]], with_chains = FALSE)
}) |> setNames(vars)
}
####Exporting the posterior distributions####
#For posterior analysis, you'll want to have the exact posterior estimates of the parameter values.
#These can be extracted from the cmdstanr object using a bespoke function
cmdstanr_extract_samples <- function(fit_obj) {
#credit to Andrew Johnson for this code (source: https://discourse.mc-stan.org/t/rstan-read-stan-csv-throwing-error-with-cmdstan-models-versions-2-35/35665/7)
vars <- fit_obj$metadata()$stan_variables
draws <- posterior::as_draws_rvars(fit_obj$draws())
lapply(vars, \(var_name){
posterior::draws_of(draws[[var_name]], with_chains = FALSE)
}) |> setNames(vars)
}
multisite_post <- cmdstanr_extract_samples(multisite_samples)
multisite_post$site_mu_female
multisite_post$mu_female
str(multisite_post$mu_female)
#IMPORTANT: To ensure reproducibility, you can also extract the random seed used to generate your model
#and then place the seed in the samples call using the argument
#seed = [whatever number you were given]
get_seed <- function(cmdstan_object) {
string <- as.numeric(stringr::str_extract(cmdstan_object$output()[[1]][grep("seed", cmdstan_object$output()[[1]])], pattern = "[0-9]{1,}"))
string
}
get_seed(multisite_samples)
known_mixture_stanmodel <- cmdstan_model("./Scripts/LSI_known_specimens.stan")
mcmc_trace(single_assemblage_samples$draws(), regex_pars = "mu_female[1]")
mcmc_trace(multisite_samples$draws(), regex_pars = "mu_female")
mcmc_trace(multisite_samples$draws(), regex_pars = "mu_female[1,1]")
mcmc_trace(multisite_samples$draws(), regex_pars = "site_mu_female[1]")
mcmc_trace(multisite_samples$draws(), pars = "site_mu_female[1]")
mcmc_trace(multisite_samples$draws(), pars = "mu_female[1,1]")
mcmc_trace(multisite_samples$draws(), pars = "grand_theta[1]")
mcmc_trace(multisite_samples$draws(), regex_pars = "grand_theta[1]")
mcmc_trace(multisite_samples$draws(), regex_pars = "grand_theta")
mcmc_trace(multisite_samples$draws(), pars = "grand_theta")
mcmc_trace(multisite_samples$draws(), pars = "grand_theta[1]")
mcmc_trace(multisite_samples$draws(), pars = "grand_mu_immature")
mcmc_trace(multisite_samples$draws(), pars = "grand_sigma_immature")
single_assemblage_theta1_plot <- mcmc_trace(multisite_samples, pars = "grand_theta[1]") + labs(title = expression(paste(theta[1])), y = element_blank()) + theme(plot.title = element_text(hjust = 0.5))
#
single_assemblage_theta1_plot <- mcmc_trace(multisite_samples, pars = "grand_theta[1]") + labs(title = expression(paste(theta[1])), y = element_blank()) + theme(plot.title = element_text(hjust = 0.5))
mcmc_trace(multisite_samples, pars = "grand_theta[1]") + labs(title = expression(paste(theta[1])), y = element_blank()) + theme(plot.title = element_text(hjust = 0.5))
library("ggplot2")
mcmc_trace(multisite_samples, pars = "grand_theta[1]") + labs(title = expression(paste(theta[1])), y = element_blank()) + theme(plot.title = element_text(hjust = 0.5))
mcmc_trace(multisite_samples, pars = "grand_theta[1]")
mcmc_trace(multisite_samples$draws(), pars = "grand_theta[1]") + labs(title = expression(paste(theta[1])), y = element_blank()) + theme(plot.title = element_text(hjust = 0.5))
single_assemblage_theta1_plot <- mcmc_trace(multisite_samples$draws(), pars = "grand_theta[1]") + labs(title = expression(paste(theta[1])), y = element_blank()) + theme(plot.title = element_text(hjust = 0.5))
single_assemblage_theta2_plot <- mcmc_trace(multisite_samples$draws(), pars = "grand_theta[2]") + labs(title = expression(paste(theta[2])), y = element_blank()) + theme(plot.title = element_text(hjust = 0.5))
single_assemblage_theta3_plot <- mcmc_trace(multisite_samples$draws(), pars = "grand_theta[3]") + labs(title = expression(paste(theta[3])), y = element_blank()) + theme(plot.title = element_text(hjust = 0.5))
single_assemblage_mu1_plot <- mcmc_trace(multisite_samples$draws(), pars = "grand_mu_immature") + labs(title = expression(paste(mu[1])), y = element_blank()) + theme(plot.title = element_text(hjust = 0.5))
single_assemblage_mu2_plot <- mcmc_trace(multisite_samples$draws(), pars = "grand_mu_female") + labs(title = expression(paste(mu[2])), y = element_blank()) + theme(plot.title = element_text(hjust = 0.5))
single_assemblage_mu3_plot <- mcmc_trace(multisite_samples$draws(), pars = "grand_mu_male") + labs(title = expression(paste(mu[3])), y = element_blank()) + theme(plot.title = element_text(hjust = 0.5))
single_assemblage_sigma1_plot <- mcmc_trace(multisite_samples$draws(), pars = "grand_sigma_immature") + labs(title = expression(paste(sigma[1])), y = element_blank()) + theme(plot.title = element_text(hjust = 0.5))
single_assemblage_sigma2_plot <- mcmc_trace(multisite_samples$draws(), pars = "grand_sigma_female") + labs(title = expression(paste(sigma[2])), y = element_blank()) + theme(plot.title = element_text(hjust = 0.5))
single_assemblage_sigma3_plot <- mcmc_trace(multisite_samples$draws(), pars = "grand_sigma_male") + labs(title = expression(paste(sigma[3])), y = element_blank()) + theme(plot.title = element_text(hjust = 0.5))
single_assemblage_trace_plot <- ggarrange(single_assemblage_theta1_plot, single_assemblage_theta2_plot, single_assemblage_theta3_plot, single_assemblage_mu1_plot, single_assemblage_mu2_plot, single_assemblage_mu3_plot, single_assemblage_sigma1_plot, single_assemblage_sigma2_plot, single_assemblage_sigma3_plot, common.legend = T, legend = "bottom")
??ggarrange
library("ggpubr")
single_assemblage_trace_plot <- ggarrange(single_assemblage_theta1_plot, single_assemblage_theta2_plot, single_assemblage_theta3_plot, single_assemblage_mu1_plot, single_assemblage_mu2_plot, single_assemblage_mu3_plot, single_assemblage_sigma1_plot, single_assemblage_sigma2_plot, single_assemblage_sigma3_plot, common.legend = T, legend = "bottom")
annotate_figure(single_assemblage_trace_plot, top = text_grob("Single Assemblage Simulation", face = "bold", size = 14))
